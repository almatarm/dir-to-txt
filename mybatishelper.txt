***$$$@@@ /pom.xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.almatarm</groupId>
    <artifactId>MyBatisHelper</artifactId>
    <version>1.0</version>
    <packaging>jar</packaging>
    <repositories>
        <repository>
            <id>unknown-jars-temp-repo</id>
            <name>A temporary repository created by NetBeans for libraries and jars it could not identify. Please replace the dependencies in this repository with correct ones and delete this repository.</name>
            <url>file:${project.basedir}/lib</url>
        </repository>
    </repositories>
    <dependencies>
        <dependency>
            <groupId>unknown.binary</groupId>
            <artifactId>AbsoluteLayout</artifactId>
            <version>SNAPSHOT</version>
        </dependency>
        <dependency>
            <groupId>org.apache.velocity</groupId>
            <artifactId>velocity</artifactId>
            <version>1.7</version>
            <type>jar</type>
        </dependency>
        <dependency>
            <groupId>net.java.dev.inflector</groupId>
            <artifactId>inflector</artifactId>
            <version>0.7.0</version>
        </dependency>
    </dependencies>
    <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.source>1.8</maven.compiler.source>
        <maven.compiler.target>1.8</maven.compiler.target>
    </properties>
</project>
*** end *** end ***
***$$$@@@ /src/main/resources/mybatis-service
#*
            ____                  _          ___                 _ 
           / ___|  ___ _ ____   _(_) ___ ___|_ _|_ __ ___  _ __ | |
           \___ \ / _ \ '__\ \ / / |/ __/ _ \| || '_ ` _ \| '_ \| |
            ___) |  __/ |   \ V /| | (_|  __/| || | | | | | |_) | |
           |____/ \___|_|    \_/ |_|\___\___|___|_| |_| |_| .__/|_|
                                               |_|      
*#		
    //**************************************************************************
    // ${Dbo} ServiceImpl
    //**************************************************************************
#*  ############################################################################
                                    Get All
*#  ############################################################################
  
    @Override
    public List<${Type}> get${Dbos}() {
        SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession();
        try {
            ${dObj.mapper} ${dObj.mapperL} = sqlSession.getMapper(${dObj.mapper}.class);
            return ${dObj.mapperL}.get${Dbos}();
	} finally {
            sqlSession.close();
	}
    }

#foreach ($field in ${dObj.getCollectionFields()})
    @Override
    public List<${Type}> get${Dbos}With${field.propertyU}() {
        SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession();
        try {
            ${dObj.mapper} ${dObj.mapperL} = sqlSession.getMapper(${dObj.mapper}.class);    
            List<${Type}> $Util.toSmall(${Dbos}) = ${dObj.mapperL}.get${Dbos}With${field.propertyU}();
            for(${Type} ${dbo} : $Util.toSmall(${Dbos})) {
                update${Dbo}${field.propertyU}(${dbo});
            }
            return $Util.toSmall(${Dbos});
	} finally {
            sqlSession.close();
	}
    }

    private void update${Dbo}${field.propertyU}(${Type} ${dbo}) {
        for(${field.javaType} $Util.toSmall(${field.javaType}) : ${dbo}.getTags()) {
            ${Util.toSmall(${field.javaType})}.set${Dbo}(${dbo});
        }
    }
#end
#*  ############################################################################
                                  Select Alone 
*#  ############################################################################
#foreach ($field in ${dObj.getSelectAloneFields()})

    @Override
    public List<${field.javaType}> get${Dbo}$Noun.pluralOf(${field.propertyU})List() {
        SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession();
        try {
            ${dObj.mapper} ${dObj.mapperL} = sqlSession.getMapper(${dObj.mapper}.class);
            return ${dObj.mapperL}.get${Dbo}$Noun.pluralOf(${field.propertyU})List();
        } finally {
            sqlSession.close();
	}
    }
#end
#*  ############################################################################
                                    Searchable
*#  ############################################################################
#if ( ${dObj.hasSearchableFields()} )
#if ( !${dObj.isSearchableUnique()} )
    
    @Override
    public List<${Type}> find${Dbos}(${Type} ${dbo}) {
        SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession();
        try {
            ${dObj.mapper} ${dObj.mapperL} = sqlSession.getMapper(${dObj.mapper}.class);
            return ${dObj.mapperL}.find${Dbos}(${dbo});
        } finally {
            sqlSession.close();
	}
    }

#foreach ($field in ${dObj.getCollectionFields()})
    @Override
    public List<${Type}> find${Dbos}With${field.propertyU}(${Type} ${dbo}) {
        SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession();
        try {
            ${dObj.mapper} ${dObj.mapperL} = sqlSession.getMapper(${dObj.mapper}.class);
            List<${Type}> $Util.toSmall(${Dbos}) = ${dObj.mapperL}.find${Dbos}With${field.propertyU}(${dbo});
            for(${Type} a${Dbo} : $Util.toSmall(${Dbos})) {
                update${Dbo}${field.propertyU}(a${Dbo});
            }
            return $Util.toSmall(${Dbos});
        } finally {
            sqlSession.close();
	}
    }
#end
#end

    @Override
    public List<${Type}> find${Dbos}Like(${Type} ${dbo}) {
        SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession();
        try {
            ${dObj.mapper} ${dObj.mapperL} = sqlSession.getMapper(${dObj.mapper}.class);
            return ${dObj.mapperL}.find${Dbos}Like(${dbo});
        } finally {
            sqlSession.close();
	}
    }

#foreach ($field in ${dObj.getCollectionFields()})
    @Override
    public List<${Type}> find${Dbos}With${field.propertyU}Like(${Type} ${dbo}) {
        SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession();
        try {
            ${dObj.mapper} ${dObj.mapperL} = sqlSession.getMapper(${dObj.mapper}.class);
            List<${Type}> $Util.toSmall(${Dbos}) = ${dObj.mapperL}.find${Dbos}With${field.propertyU}Like(${dbo});
            for(${Type} a${Dbo} : $Util.toSmall(${Dbos})) {
                update${Dbo}${field.propertyU}(a${Dbo});
            }
            return $Util.toSmall(${Dbos});
        } finally {
            sqlSession.close();
	}
    }
#end
#end
#*  ############################################################################
                                     Find By 
*#  ############################################################################
#foreach ($field in ${dObj.getFindByFields()})

    @Override
#if( ${field.unique} ) 
    public ${Type} find${Dbo}By${field.propertyU}(${field.javaType} ${field.property}) {
        SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession();
        try {
            ${dObj.mapper} ${dObj.mapperL} = sqlSession.getMapper(${dObj.mapper}.class);
            return ${dObj.mapperL}.find${Dbo}By${field.propertyU}(${field.property});
#else 
    public List<${Type}> find${Dbos}By${field.propertyU}(${field.javaType} ${field.property}) {
        SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession();
        try {
            ${dObj.mapper} ${dObj.mapperL} = sqlSession.getMapper(${dObj.mapper}.class); 
            ${Type} ${dbo} = new ${Type}();
            ${dbo}.set${field.propertyU}(${field.property});
            return find${Dbos}(${dbo});
#end
        } finally {
            sqlSession.close();
	}
    }

#foreach ($cfield in ${dObj.getCollectionFields()})
    @Override
#if( ${field.unique} ) 
    public ${Type} find${Dbo}With${cfield.propertyU}By${field.propertyU}(${field.javaType} ${field.property}) { 
        SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession();
        try {
            ${dObj.mapper} ${dObj.mapperL} = sqlSession.getMapper(${dObj.mapper}.class); 
            ${Type} ${dbo} = ${dObj.mapperL}.find${Dbo}With${cfield.propertyU}By${field.propertyU}(${field.property});
            update${Dbo}${cfield.propertyU}(${dbo});
            return ${dbo};
#else 
    public List<${Type}> find${Dbos}With${cfield.propertyU}By${field.propertyU}(${field.javaType} ${field.property}) {
        SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession();
        try {
            ${dObj.mapper} ${dObj.mapperL} = sqlSession.getMapper(${dObj.mapper}.class); 
            ${Type} ${dbo} = new ${Dbo}();
            ${dbo}.set${field.propertyU}(${field.property});
        
            List<${Type}> $Util.toSmall(${Dbos}) = find${Dbos}With${cfield.propertyU}(${dbo});
            for(${Type} ${dbo} : $Util.toSmall(${Dbos})) {
                update${Dbo}${field.propertyU}(${dbo});
            }
            return $Util.toSmall(${Dbos});
#end
        } finally {
            sqlSession.close();
	}
    }
#end
#end

#*  ############################################################################
                            Insert, Update & Delete
*#  ############################################################################ 
    
    @Override
    public ${Type} save${Dbo}(${Type} ${dbo}) {
        SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession();
        try {
            ${dObj.mapper} ${dObj.mapperL} = sqlSession.getMapper(${dObj.mapper}.class); 
            if(${dbo}.getId() == null) {
                ${dObj.mapperL}.insert${Dbo}(${dbo});
            } else {
                ${dObj.mapperL}.update${Dbo}(${dbo});
            }
            sqlSession.commit();
            return ${dbo};
        } finally {
            sqlSession.close();
	}
    }

    @Override
    public void delete${Dbo}(Long id) {
        SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession();
        try {
            ${dObj.mapper} ${dObj.mapperL} = sqlSession.getMapper(${dObj.mapper}.class); 
            ${dObj.mapperL}.delete${Dbo}(id);
            sqlSession.commit();
        } finally {
            sqlSession.close();
	}
    }    
*** end *** end ***
***$$$@@@ /src/main/resources/Service
#*
                    ____                  _          
                   / ___|  ___ _ ____   _(_) ___ ___ 
                   \___ \ / _ \ '__\ \ / / |/ __/ _ \
                    ___) |  __/ |   \ V /| | (_|  __/
                   |____/ \___|_|    \_/ |_|\___\___|

*#
    //**************************************************************************
    // ${Dbo} Service
    //**************************************************************************
#*  ############################################################################
                                    Get All
*#  ############################################################################

    public List<${Type}> get${Dbos}();
#foreach ($field in ${dObj.getCollectionFields()})
    
    public List<${Type}> get${Dbos}With${field.propertyU}();
#end
#*  ############################################################################
                                  Select Alone 
*#  ############################################################################
#foreach ($field in ${dObj.getSelectAloneFields()})

    public List<${field.javaType}> get${Dbo}$Noun.pluralOf(${field.propertyU})List();
#end
#*  ############################################################################
                                    Searchable
*#  ############################################################################
#if ( ${dObj.hasSearchableFields()} )
#if ( !${dObj.isSearchableUnique()} )    

    public List<${Type}> find${Dbos}(${Type} ${dbo});

#foreach ($field in ${dObj.getCollectionFields()})
    public List<${Type}> find${Dbos}With${field.propertyU}(${Type} ${dbo});
#end
#end

    public List<${Type}> find${Dbos}Like(${Type} ${dbo});
    
#foreach ($field in ${dObj.getCollectionFields()})
    public List<${Type}> find${Dbos}With${field.propertyU}Like(${Type} ${dbo});
#end
#end
#*  ############################################################################
                                     Find By 
*#  ############################################################################
#foreach ($field in ${dObj.getFindByFields()})
#if( ${field.unique} ) #set ( $rType = ${Type} ) #else #set ( $rType = "List<$Type>" ) #end
#if( ${field.unique} ) #set ( $DBO = ${Dbo} )   #else #set ( $DBO = ${Dbos} )        #end

    public ${rType} find${DBO}By${field.propertyU}(${field.javaType} ${field.property});
#foreach ($cfield in ${dObj.getCollectionFields()})

    public ${rType} find${DBO}With${cfield.propertyU}By${field.propertyU}(${field.javaType} ${field.property});
#end
#end
#*  ############################################################################
                            Insert, Update & Delete
*#  ############################################################################ 

    public ${Type} save${Dbo}(${Type} ${dbo});
    
    public void delete${Dbo}(Long id);

#*
            ____                  _          ___                 _ 
           / ___|  ___ _ ____   _(_) ___ ___|_ _|_ __ ___  _ __ | |
           \___ \ / _ \ '__\ \ / / |/ __/ _ \| || '_ ` _ \| '_ \| |
            ___) |  __/ |   \ V /| | (_|  __/| || | | | | | |_) | |
           |____/ \___|_|    \_/ |_|\___\___|___|_| |_| |_| .__/|_|
                                               |_|      
*#		
    //**************************************************************************
    // ${Dbo} ServiceImpl
    //**************************************************************************
#*  ############################################################################
                                    Get All
*#  ############################################################################
    
    @Autowired
    private ${dObj.mapper} ${dObj.mapperL};

    @Override
    public List<${Type}> get${Dbos}() {
        return ${dObj.mapperL}.get${Dbos}();
    }

#foreach ($field in ${dObj.getCollectionFields()})
    @Override
    public List<${Type}> get${Dbos}With${field.propertyU}() {
        List<${Type}> $Util.toSmall(${Dbos}) = ${dObj.mapperL}.get${Dbos}With${field.propertyU}();
        for(${Type} ${dbo} : $Util.toSmall(${Dbos})) {
            update${Dbo}${field.propertyU}(${dbo});
        }
        return $Util.toSmall(${Dbos});
    }

    private void update${Dbo}${field.propertyU}(${Type} ${dbo}) {
        for(${field.javaType} $Util.toSmall(${field.javaType}) : ${dbo}.getTags()) {
            ${Util.toSmall(${field.javaType})}.set${Dbo}(${dbo});
        }
    }
#end
#*  ############################################################################
                                  Select Alone 
*#  ############################################################################
#foreach ($field in ${dObj.getSelectAloneFields()})

    @Override
    public List<${field.javaType}> get${Dbo}$Noun.pluralOf(${field.propertyU})List() {
        return ${dObj.mapperL}.get${Dbo}$Noun.pluralOf(${field.propertyU})List();
    }
#end
#*  ############################################################################
                                    Searchable
*#  ############################################################################
#if ( ${dObj.hasSearchableFields()} )
#if ( !${dObj.isSearchableUnique()} )
    
    @Override
    public List<${Type}> find${Dbos}(${Type} ${dbo}) {
        return ${dObj.mapperL}.find${Dbos}(${dbo});
    }

#foreach ($field in ${dObj.getCollectionFields()})
    @Override
    public List<${Type}> find${Dbos}With${field.propertyU}(${Type} ${dbo}) {
        List<${Type}> $Util.toSmall(${Dbos}) = ${dObj.mapperL}.find${Dbos}With${field.propertyU}(${dbo});
        for(${Type} a${Dbo} : $Util.toSmall(${Dbos})) {
            update${Dbo}${field.propertyU}(a${Dbo});
        }
        return $Util.toSmall(${Dbos});
    }
#end
#end

    @Override
    public List<${Type}> find${Dbos}Like(${Type} ${dbo}) {
        return ${dObj.mapperL}.find${Dbos}Like(${dbo});
    }

#foreach ($field in ${dObj.getCollectionFields()})
    @Override
    public List<${Type}> find${Dbos}With${field.propertyU}Like(${Type} ${dbo}) {
        List<${Type}> $Util.toSmall(${Dbos}) = ${dObj.mapperL}.find${Dbos}With${field.propertyU}Like(${dbo});
        for(${Type} a${Dbo} : $Util.toSmall(${Dbos})) {
            update${Dbo}${field.propertyU}(a${Dbo});
        }
        return $Util.toSmall(${Dbos});
    }
#end
#end
#*  ############################################################################
                                     Find By 
*#  ############################################################################
#foreach ($field in ${dObj.getFindByFields()})

    @Override
#if( ${field.unique} ) 
    public ${Type} find${Dbo}By${field.propertyU}(${field.javaType} ${field.property}) {
        return ${dObj.mapperL}.find${Dbo}By${field.propertyU}(${field.property});
#else 
    public List<${Type}> find${Dbos}By${field.propertyU}(${field.javaType} ${field.property}) {
        ${Type} ${dbo} = new ${Type}();
        ${dbo}.set${field.propertyU}(${field.property});
        return find${Dbos}(${dbo});
#end
    }

#foreach ($cfield in ${dObj.getCollectionFields()})
    @Override
#if( ${field.unique} ) 
    public ${Type} find${Dbo}With${cfield.propertyU}By${field.propertyU}(${field.javaType} ${field.property}) {
        ${Type} ${dbo} = ${dObj.mapperL}.find${Dbo}With${cfield.propertyU}By${field.propertyU}(${field.property});
        update${Dbo}${cfield.propertyU}(${dbo});
        return ${dbo};
#else 
    public List<${Type}> find${Dbos}With${cfield.propertyU}By${field.propertyU}(${field.javaType} ${field.property}) {
        ${Type} ${dbo} = new ${Dbo}();
        ${dbo}.set${field.propertyU}(${field.property});
        
        List<${Type}> $Util.toSmall(${Dbos}) = find${Dbos}With${cfield.propertyU}(${dbo});
        for(${Type} ${dbo} : $Util.toSmall(${Dbos})) {
            update${Dbo}${field.propertyU}(${dbo});
        }
        return $Util.toSmall(${Dbos});
#end
    }
#end
#end

#*  ############################################################################
                            Insert, Update & Delete
*#  ############################################################################ 
    
    @Override
    public ${Type} save${Dbo}(${Type} ${dbo}) {
        if(${dbo}.getId() == null) {
            ${dObj.mapperL}.insert${Dbo}(${dbo});
        } else {
            ${dObj.mapperL}.update${Dbo}(${dbo});
        }
        return ${dbo};
    }

    @Override
    public void delete${Dbo}(Long id) {
        ${dObj.mapperL}.delete${Dbo}(id);
    }


#*
                        __  __                             
                       |  \/  | __ _ _ __  _ __   ___ _ __ 
                       | |\/| |/ _` | '_ \| '_ \ / _ \ '__|
                       | |  | | (_| | |_) | |_) |  __/ |   
                       |_|  |_|\__,_| .__/| .__/ \___|_|   
                                    |_|   |_|              
*#
    //**************************************************************************
    // ${Dbo} Mapper
    //**************************************************************************
#*  ############################################################################
                                    Get All
*#  ############################################################################
    
    public List<${Type}> get${Dbos}();
#foreach ($field in ${dObj.getCollectionFields()})

    public List<${Type}> get${Dbos}With${field.propertyU}();
#end
#*  ############################################################################
                                  Select Alone 
*#  ############################################################################
#foreach ($field in ${dObj.getSelectAloneFields()})

    public List<${field.javaType}> get${Dbo}$Noun.pluralOf(${field.propertyU})List();
#end
#*  ############################################################################
                                    Searchable
*#  ############################################################################
#if ( ${dObj.hasSearchableFields()} )
#if ( !${dObj.isSearchableUnique()} )

    public List<${Type}> find${Dbos}(${Type} ${dbo});

#foreach ($field in ${dObj.getCollectionFields()})
    public List<${Type}> find${Dbos}With${field.propertyU}(${Type} ${dbo});
#end
#end

    public List<${Type}> find${Dbos}Like(${Type} ${dbo});
#foreach ($field in ${dObj.getCollectionFields()})
    
    public List<${Type}> find${Dbos}With${field.propertyU}Like(${Type} ${dbo});
#end
#end
#*  ############################################################################
                                     Find By 
*#  ############################################################################
#foreach ($field in ${dObj.getFindByFields()})
#if( ${field.unique} ) 
    
    public ${Type} find${Dbo}By${field.propertyU}(${field.javaType} ${field.property});

#foreach ($cfield in ${dObj.getCollectionFields()})
    public ${Type} find${Dbo}With${cfield.propertyU}By${field.propertyU}(${field.javaType} ${field.property});
#end
#end
#end

#*  ############################################################################
                            Insert, Update & Delete
*#  ############################################################################ 

    public void insert${Dbo}(${Type} ${dbo});

    public void update${Dbo}(${Type} ${dbo});

    public void delete${Dbo}(Long id);

#*
                __  __                              __  ____  __ _     
               |  \/  | __ _ _ __  _ __   ___ _ __  \ \/ /  \/  | |    
               | |\/| |/ _` | '_ \| '_ \ / _ \ '__|  \  /| |\/| | |    
               | |  | | (_| | |_) | |_) |  __/ |     /  \| |  | | |___ 
               |_|  |_|\__,_| .__/| .__/ \___|_|    /_/\_\_|  |_|_____|
                            |_|   |_|                                  

*#
    //**************************************************************************
    // ${Dbo} Mapper XML
    //**************************************************************************
#*  ############################################################################
                                    Get All
*#  ############################################################################

#macro( columns_list )
#if(${dObj.hasAssociationField()}) 
${dObj.QualifedColumnsList}
#else 
${dObj.ColumnsList}
#end
#end

#macro( association_joins  $last_statement)
#foreach ($field in ${dObj.getAssociationFields()})
        LEFT OUTER JOIN ${field.dObj.Table} ON ${dObj.Table}.${field.Column} = ${field.dObj.Table}.${field.dObj.IdField.Column}#if( !$foreach.hasNext && $last_statement );$new_line#else $new_line#end
#end
#end

    <select id="get${Dbos}" resultMap="${ResultMap}">
        SELECT
            #columns_list()
        FROM 
            ${dObj.Table}
#association_joins(true)
     </select>
    
#foreach ($field in ${dObj.getCollectionFields()})
    <select id="get${Dbos}With${field.propertyU}" resultMap="${ResultMap}">
        SELECT
            #columns_list()
        FROM 
            ${dObj.Table}
#association_joins(false)
        LEFT OUTER JOIN ${field.dObj.Table} ON ${dObj.Table}.ID = ${field.dObj.Table}.${field.fKey};
    </select>    
#end
#*  ############################################################################
                                  Select Alone 
*#  ############################################################################
#foreach ($field in ${dObj.getSelectAloneFields()})

    <select id="get${Dbo}$Noun.pluralOf(${field.propertyU})List"  resultType="${field.javaType}">
        SELECT DISTINCT 
            ${field.column}
        FROM 
            ${dObj.Table}    
    </select>
#end
#*  ############################################################################
                                    Searchable
*#  ############################################################################
#if ( ${dObj.hasSearchableFields()} )
#if ( !${dObj.isSearchableUnique()} )
   
    <select id="find${Dbos}" resultMap="${ResultMap}">
        SELECT
            #columns_list()
        FROM
            ${dObj.Table}
#association_joins(false)
        <where>
#foreach ($sfield in ${dObj.getSearchableFields()})
            <if test="${sfield.property} != null">
                ${dObj.Table}.${sfield.column} = #{${sfield.property}}
            </if>
#end
        </where>
    </select>
    
#foreach ($field in ${dObj.getCollectionFields()})
    <select id="find${Dbos}With${field.propertyU}" resultMap="${ResultMap}">
        SELECT
${dObj.qualifedColumnsList},
${field.qualifedColumnsList}
        FROM 
            ${dObj.Table}
        LEFT OUTER JOIN 
            ${field.dObj.Table} 
        ON 
            ${dObj.Table}.ID = ${field.dObj.Table}.${field.fKey}
        <where>
#foreach ($sfield in ${dObj.getSearchableFields()})
            <if test="${sfield.property} != null">
                ${dObj.Table}.${sfield.column} = #{${sfield.property}}
            </if>
#end
        </where>
    </select>    
#end
#end

    <select id="find${Dbos}Like" resultMap="${ResultMap}">
        SELECT
            #columns_list()
        FROM
            ${dObj.Table}
#association_joins(false)
        <where>
#foreach ($sfield in ${dObj.getSearchableFields()})
            <if test="${sfield.property} != null">
                ${dObj.Table}.${sfield.column} LIKE #{${sfield.property}}
            </if>
#end
        </where>
    </select>
    
#foreach ($field in ${dObj.getCollectionFields()})
    <select id="find${Dbos}With${field.propertyU}Like" resultMap="${ResultMap}">
        SELECT
${dObj.qualifedColumnsList},
${field.qualifedColumnsList}
        FROM 
            ${dObj.Table}
        LEFT OUTER JOIN 
            ${field.dObj.Table} 
        ON 
            ${dObj.Table}.ID = ${field.dObj.Table}.${field.fKey}
        <where>
#foreach ($sfield in ${dObj.getSearchableFields()})
            <if test="${sfield.property} != null">
                ${dObj.Table}.${sfield.column} LIKE #{${sfield.property}}
            </if>
#end
        </where>
    </select>    
#end
#end
#*  ############################################################################
                                     Find By 
*#  ############################################################################
#foreach ($field in ${dObj.getFindByFields()})
#if( ${field.unique} ) 
    
    <select id="find${Dbo}By${field.propertyU}" parameterType="${field.javaType}" resultMap="${ResultMap}">
        SELECT
            #columns_list()
        FROM
            ${dObj.Table}
#association_joins(false)
        WHERE
            ${field.column} = #{${field.property}}
    </select>

#foreach ($cfield in ${dObj.getCollectionFields()})
    <select id="find${Dbo}With${cfield.propertyU}By${field.propertyU}" parameterType="${field.javaType}" 
        resultMap="${ResultMap}">
        SELECT
${dObj.qualifedColumnsList},
${cfield.qualifedColumnsList}
        FROM 
            ${dObj.Table}
        LEFT OUTER JOIN 
            ${cfield.dObj.Table} 
        ON 
            ${dObj.Table}.ID = ${cfield.dObj.Table}.${cfield.fKey}
        WHERE
            ${dObj.Table}.${field.column} = #{${field.property}}
    </select>    
#end
#end
#end

#*  ############################################################################
                            Insert, Update & Delete
*#  ############################################################################ 

    <insert id="insert${Dbo}" parameterType="${dObj.Type}" useGeneratedKeys="true" 
            keyProperty="id">
        INSERT INTO 
            ${Table} (${dObj.ColumnListInsert}) 
        VALUES 
            (${PropListInsertNoID})    
    </insert>
     
    <update id="update${Dbo}" parameterType="${Type}">
        UPDATE ${dObj.Table} SET
${dObj.UpdateList}
        WHERE 
            ID = #{id}
    </update> 
        
    <delete id="delete${Dbo}" parameterType="long">
        DELETE FROM ${Table} WHERE ID = #{id}
    </delete>
    
    
*** end *** end ***
***$$$@@@ /src/main/java/com/almatarm/mybatishelper/Gen.java
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.almatarm.mybatishelper;

/**
 *
 * @author almatarm
 */
public class Gen extends javax.swing.JFrame {

    /**
     * Creates new form Gen
     */
    public Gen() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane3 = new javax.swing.JScrollPane();
        in = new javax.swing.JTextArea();
        jScrollPane4 = new javax.swing.JScrollPane();
        out = new javax.swing.JTextArea();
        jComboBox1 = new javax.swing.JComboBox<>();
        generate = new javax.swing.JButton();
        javaType = new javax.swing.JTextField();
        sqlTable = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        methods = new javax.swing.JTextArea();
        menuBar = new javax.swing.JMenuBar();
        fileMenu = new javax.swing.JMenu();
        openMenuItem = new javax.swing.JMenuItem();
        saveMenuItem = new javax.swing.JMenuItem();
        saveAsMenuItem = new javax.swing.JMenuItem();
        exitMenuItem = new javax.swing.JMenuItem();
        editMenu = new javax.swing.JMenu();
        cutMenuItem = new javax.swing.JMenuItem();
        copyMenuItem = new javax.swing.JMenuItem();
        pasteMenuItem = new javax.swing.JMenuItem();
        deleteMenuItem = new javax.swing.JMenuItem();
        helpMenu = new javax.swing.JMenu();
        contentsMenuItem = new javax.swing.JMenuItem();
        aboutMenuItem = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        in.setColumns(20);
        in.setRows(5);
        in.setText("        <id     property=\"id\"             column=\"ID\" />\n        <result property=\"code\"           column=\"Code\" />\n        <result property=\"description\"    column=\"Descr\" />\n        <result property=\"symbol\"         column=\"Symbol\" />\n        <result property=\"provider\"       column=\"Provider\" />\n        <result property=\"fractionDigits\" column=\"FractDigt\" />");
        jScrollPane3.setViewportView(in);

        out.setColumns(20);
        out.setRows(5);
        jScrollPane4.setViewportView(out);

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));

        generate.setText("Generate");
        generate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                generateActionPerformed(evt);
            }
        });

        javaType.setText("java");

        sqlTable.setText("table");

        methods.setColumns(20);
        methods.setRows(5);
        jScrollPane1.setViewportView(methods);

        fileMenu.setMnemonic('f');
        fileMenu.setText("File");

        openMenuItem.setMnemonic('o');
        openMenuItem.setText("Open");
        fileMenu.add(openMenuItem);

        saveMenuItem.setMnemonic('s');
        saveMenuItem.setText("Save");
        fileMenu.add(saveMenuItem);

        saveAsMenuItem.setMnemonic('a');
        saveAsMenuItem.setText("Save As ...");
        saveAsMenuItem.setDisplayedMnemonicIndex(5);
        fileMenu.add(saveAsMenuItem);

        exitMenuItem.setMnemonic('x');
        exitMenuItem.setText("Exit");
        exitMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitMenuItemActionPerformed(evt);
            }
        });
        fileMenu.add(exitMenuItem);

        menuBar.add(fileMenu);

        editMenu.setMnemonic('e');
        editMenu.setText("Edit");

        cutMenuItem.setMnemonic('t');
        cutMenuItem.setText("Cut");
        editMenu.add(cutMenuItem);

        copyMenuItem.setMnemonic('y');
        copyMenuItem.setText("Copy");
        editMenu.add(copyMenuItem);

        pasteMenuItem.setMnemonic('p');
        pasteMenuItem.setText("Paste");
        editMenu.add(pasteMenuItem);

        deleteMenuItem.setMnemonic('d');
        deleteMenuItem.setText("Delete");
        editMenu.add(deleteMenuItem);

        menuBar.add(editMenu);

        helpMenu.setMnemonic('h');
        helpMenu.setText("Help");

        contentsMenuItem.setMnemonic('c');
        contentsMenuItem.setText("Contents");
        helpMenu.add(contentsMenuItem);

        aboutMenuItem.setMnemonic('a');
        aboutMenuItem.setText("About");
        helpMenu.add(aboutMenuItem);

        menuBar.add(helpMenu);

        setJMenuBar(menuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addComponent(jScrollPane3))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane4))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(javaType, javax.swing.GroupLayout.PREFERRED_SIZE, 170, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(sqlTable, javax.swing.GroupLayout.PREFERRED_SIZE, 173, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 190, Short.MAX_VALUE)
                        .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, 264, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(generate))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane1)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(10, 10, 10)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 153, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 173, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 216, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(generate)
                    .addComponent(javaType, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(sqlTable, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void exitMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitMenuItemActionPerformed
        System.exit(0);
    }//GEN-LAST:event_exitMenuItemActionPerformed

   
    private void generateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_generateActionPerformed
//       DObject param = DObject.of(in.getText());
//       System.out.println(param);
    }//GEN-LAST:event_generateActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Gen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Gen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Gen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Gen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Gen().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem aboutMenuItem;
    private javax.swing.JMenuItem contentsMenuItem;
    private javax.swing.JMenuItem copyMenuItem;
    private javax.swing.JMenuItem cutMenuItem;
    private javax.swing.JMenuItem deleteMenuItem;
    private javax.swing.JMenu editMenu;
    private javax.swing.JMenuItem exitMenuItem;
    private javax.swing.JMenu fileMenu;
    private javax.swing.JButton generate;
    private javax.swing.JMenu helpMenu;
    private javax.swing.JTextArea in;
    private javax.swing.JComboBox<String> jComboBox1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JTextField javaType;
    private javax.swing.JMenuBar menuBar;
    private javax.swing.JTextArea methods;
    private javax.swing.JMenuItem openMenuItem;
    private javax.swing.JTextArea out;
    private javax.swing.JMenuItem pasteMenuItem;
    private javax.swing.JMenuItem saveAsMenuItem;
    private javax.swing.JMenuItem saveMenuItem;
    private javax.swing.JTextField sqlTable;
    // End of variables declaration//GEN-END:variables

}

*** end *** end ***
***$$$@@@ /src/main/java/com/almatarm/mybatishelper/CodeGen.form
<?xml version="1.0" encoding="UTF-8" ?>

<Form version="1.3" maxVersion="1.9" type="org.netbeans.modules.form.forminfo.JFrameFormInfo">
  <Properties>
    <Property name="defaultCloseOperation" type="int" value="3"/>
  </Properties>
  <SyntheticProperties>
    <SyntheticProperty name="formSizePolicy" type="int" value="1"/>
    <SyntheticProperty name="generateCenter" type="boolean" value="false"/>
  </SyntheticProperties>
  <AuxValues>
    <AuxValue name="FormSettings_autoResourcing" type="java.lang.Integer" value="0"/>
    <AuxValue name="FormSettings_autoSetComponentName" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_generateFQN" type="java.lang.Boolean" value="true"/>
    <AuxValue name="FormSettings_generateMnemonicsCode" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_i18nAutoMode" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_layoutCodeTarget" type="java.lang.Integer" value="1"/>
    <AuxValue name="FormSettings_listenerGenerationStyle" type="java.lang.Integer" value="0"/>
    <AuxValue name="FormSettings_variablesLocal" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_variablesModifier" type="java.lang.Integer" value="2"/>
    <AuxValue name="designerSize" type="java.awt.Dimension" value="-84,-19,0,5,115,114,0,18,106,97,118,97,46,97,119,116,46,68,105,109,101,110,115,105,111,110,65,-114,-39,-41,-84,95,68,20,2,0,2,73,0,6,104,101,105,103,104,116,73,0,5,119,105,100,116,104,120,112,0,0,2,-14,0,0,3,-52"/>
  </AuxValues>

  <Layout class="org.netbeans.modules.form.compat2.layouts.DesignBorderLayout"/>
  <SubComponents>
    <Component class="javax.swing.JSeparator" name="jSeparator1">
      <Constraints>
        <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.DesignBorderLayout" value="org.netbeans.modules.form.compat2.layouts.DesignBorderLayout$BorderConstraintsDescription">
          <BorderConstraints direction="Center"/>
        </Constraint>
      </Constraints>
    </Component>
    <Container class="javax.swing.JScrollPane" name="jScrollPane1">
      <AuxValues>
        <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
      </AuxValues>
      <Constraints>
        <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.DesignBorderLayout" value="org.netbeans.modules.form.compat2.layouts.DesignBorderLayout$BorderConstraintsDescription">
          <BorderConstraints direction="First"/>
        </Constraint>
      </Constraints>

      <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
      <SubComponents>
        <Component class="javax.swing.JTextArea" name="jTextArea1">
          <Properties>
            <Property name="columns" type="int" value="20"/>
            <Property name="rows" type="int" value="5"/>
          </Properties>
        </Component>
      </SubComponents>
    </Container>
  </SubComponents>
</Form>

*** end *** end ***
***$$$@@@ /src/main/java/com/almatarm/mybatishelper/Format.java
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.almatarm.mybatishelper;

/**
 *
 * @author almatarm
 */
public class Format {
    public static String cell(String val, int length) {
        while(val.length() < length)
            val += " ";
        return val;
    }   
}

*** end *** end ***
***$$$@@@ /src/main/java/com/almatarm/mybatishelper/Method.java
package com.almatarm.mybatishelper;


/**
 *
 * @author almatarm
 */
public class Method {
    public enum SQLType {
        select,
        insert,
        update,
        delete,
        ;
    }
    
    String access;
    String returnType;
    String methodName;
    String inType;
    SQLType sqlType;
    
    public Method() {
    }

    public Method(String access, String returnType, String methodName, String inType) {
        this.access = access;
        this.returnType = returnType;
        this.methodName = methodName;
        this.inType = inType;
    }

    public String getAccess() {
        return access;
    }

    public void setAccess(String access) {
        this.access = access;
    }

    public String getReturnType() {
        return returnType;
    }

    public void setReturnType(String returnType) {
        this.returnType = returnType;
    }

    public String getMethodName() {
        return methodName;
    }

    public void setMethodName(String methodName) {
        this.methodName = methodName;
    }

    public String getInType() {
        return inType;
    }

    public void setInType(String inType) {
        this.inType = inType;
    }

    public SQLType getSqlType() {
        return sqlType;
    }

    public void setSqlType(SQLType sqlType) {
        this.sqlType = sqlType;
    }

    @Override
    public String toString() {
        return "Method{" + "access=" + access + ", returnType=" + returnType + ", methodName=" + methodName + ", inType=" + inType + ", sqlType=" + sqlType + '}';
    }
    
    public static Method of(String str) {
        Method method = new Method();
        
        str = str.trim();
        
        int mark = 0;
        //Access
        String firstWord = str.substring(0, str.indexOf(" "));
        if(firstWord.equals("private") || firstWord.equals("public") 
                || firstWord.equals("package")) {
            method.setAccess(firstWord);
            mark = str.indexOf(firstWord) + firstWord.length();
        }
        
        //return value
        if(method.getAccess() == null) {
            method.setReturnType(firstWord);
            mark = str.indexOf(firstWord) + firstWord.length();
        } else {
            String returnType = str.substring(mark + 1, str.indexOf(" ", mark + 1));
            method.setReturnType(returnType);
            mark = str.indexOf(returnType) + returnType.length();
        }
        
        //method name
        String methodName = str.substring(mark + 1, str.indexOf("(", mark + 1));
        method.setMethodName(methodName);
        mark = str.indexOf(methodName) + methodName.length();
       
        //method name
        int lastIdx = str.indexOf(" ", mark + 1);
        if(lastIdx != -1) {
            String inType = str.substring(mark + 1, lastIdx);
            method.setInType(inType);
        }        
        
        if(str.contains("insert")) {
            method.setSqlType(SQLType.insert);
        } else if(str.contains("delete")) {
            method.setSqlType(SQLType.delete);
        } else if(str.contains("update")) {
            method.setSqlType(SQLType.update);
        } else {
            method.setSqlType(SQLType.select);
        }
        
        return method;
    }
}

*** end *** end ***
***$$$@@@ /src/main/java/com/almatarm/mybatishelper/Util.java
package com.almatarm.mybatishelper;

/**
 *
 * @author <a href="mailto:almatarm@gmail.com">Mufeed H. AlMatar</a>
 * @version 1.0
 */
public class Util {
    public static String toSmall(String clazz) {
        return clazz.length() > 1 ? clazz.substring(0, 1).toLowerCase() 
                    + clazz.substring(1): clazz.toLowerCase();
    }
}

*** end *** end ***
***$$$@@@ /src/main/java/com/almatarm/mybatishelper/DObject.java
package com.almatarm.mybatishelper;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;

/**
 *
 * @author almatarm
 */
public class DObject {
    
    public static enum MetadataType {
        Unique,
        FindBy,
        Searchable,
        Alone,
        ;
    }
    
    String table;
    String type;
    String resultMap;
    String mapper;
    String dbo;
    String clazz;
    List<Field> fields;
    SingleField idField;
    //ResultMap -> DObject
    LinkedHashMap<String, DObject> children = new LinkedHashMap<>();
    
    public DObject() {
        this("TABLE_NAME", "JAVA_TYPE");
    }

    public DObject(String table, String type) {
        this.table = table;
        setType(type);
        fields = new ArrayList<>();
    }

    public DObject(String table, String type, String resultMap, List<Field> fields) {
        this.table = table;
        this.type = type;
        this.resultMap = resultMap;
        this.fields = fields;
    }
    
    public String getTable() {
        return table;
    }

    public void setTable(String table) {
        this.table = table;
    }

    public List<Field> getFields() {
        return fields;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
        if(dbo == null) {
            dbo = type;
        }
    }

    public String getDbo() {
        return dbo;
    }

    public void setDbo(String dbo) {
        this.dbo = dbo;
    }

    public String getClazz() {
        return clazz;
    }

    public void setClazz(String clazz) {
        this.clazz = clazz;
    }

    public SingleField getIdField() {
        return idField;
    }

    public void setIdField(SingleField idField) {
        this.idField = idField;
    }
    
    public String getAssociationJoins() {
        StringBuilder buff = new StringBuilder();
        for(AssociationField af : getAssociationFields()) {
            String join = String.format("%s %s %s %s%s%s %s %s%s%s%s%n", 
                    "        LEFT OUTER JOIN", af.getdObj().getTable(), "ON",
                    getTable(), ".", af.getColumn(), "=", 
                    af.getdObj().getTable(), ".", 
                    af.getdObj().getIdField().getColumn(), ";");
            buff.append(join);
            buff.append("        LEFT OUTER JOIN ").append(af.getdObj().getTable())
                    .append(" ON ").append(getTable()).append(".")
                    .append(af.getColumn()).append(" = ")
                    .append(af.getdObj().getTable()).append(".")
                    .append(af.getdObj().getIdField().getProperty()).append(";");
        }
        return buff.toString();
    }
    
    public String getSmartColumnsList() {
        return hasAssociationField()?getQualifedColumnsList():getColumnsList();
    }
    
    public String getColumnsList() {
        StringBuilder builder = new StringBuilder();
        
        fields.forEach( (field) -> {
            if(field.getFieldType() == FieldType.Single)
                builder.append(((SingleField) field).getColumn()).append(", ");
        });
        
        children.values().forEach( (child) -> { 
            child.getFields().forEach( (field) -> {
            if(field.getFieldType() == FieldType.Single)
                builder.append(((SingleField) field).getColumn()).append(", ");
            });
        });
        
        String rVal = builder.toString();
        return rVal.substring(0, rVal.length() - 2);
    }
    
    public String getQualifedColumnsList() {
        StringBuilder builder = new StringBuilder();
        
        fields.forEach( (field) -> {
            if(field.getFieldType() == FieldType.Single)
                builder.append("            ").append(table).append(".")
                        .append(((SingleField) field).getColumn()).append(",\n");
        });
      
        children.values().forEach( (child) -> { 
            child.getFields().forEach( (field) -> {
            if(field.getFieldType() == FieldType.Single)
                builder.append("            ").append(table).append(".")
                        .append(((SingleField) field).getColumn()).append(",\n");
            });
        });
        
        getAssociationFields().stream().forEach((AssociationField af) -> {
            builder.append(af.getQualifedColumnsList()).append(",\n");
        });
        
        String rVal = builder.toString();
        rVal =  rVal.substring("            ".length(), rVal.length() - 2);
        return rVal;
    }
    
    public String getColumnListInsert() {
        StringBuilder builder = new StringBuilder();
        
        fields.forEach( (field) -> {
            if(field.getFieldType() == FieldType.Single 
                    && !field.getProperty().equals("id")) {
                if(builder.length() > 0) builder.append(", ");
                builder.append(((SingleField) field).getColumn());
            }
        });
        
        getAssociationFields().stream().forEach((AssociationField af) -> {
             builder.append(", ").append(af.getColumn());
        });
        
        children.values().forEach( (child) -> { 
            builder.append("\n            <if test=\"_parameter instanceof ").append(child.clazz).append("\">");
            child.getFields().forEach( (field) -> {
            if(field.getFieldType() == FieldType.Single)
                builder.append(", ").append(((SingleField) field).getColumn());
            });
            builder.append("</if>");
        });
        
        return builder.toString();
        //String rVal = builder.toString();
//        if(children.values().isEmpty()) {
//            return rVal.substring(0, rVal.length() - 2);
//        } else {
//            return rVal.replaceAll(", </if>", "</if>");
//        }
    }
    
    public String getPropListInsert() {
        StringBuilder builder = new StringBuilder();
        
        fields.forEach( (field) -> {
            if(field.getFieldType() == FieldType.Single 
                    && !field.getProperty().equals("id")) {
                if(builder.length() > 0) builder.append(", ");
                builder.append("#{").append(field.getProperty()).append("}");
            }
        });
        
        getAssociationFields().stream().forEach((AssociationField af) -> {
             builder.append(", #{").append(af.getProperty() + "." + af.getdObj().getIdField().getProperty()).append("}");
        });
        
        children.values().forEach( (child) -> { 
            builder.append("\n            <if test=\"_parameter instanceof ").append(child.clazz).append("\">");
            child.getFields().forEach( (field) -> {
            if(field.getFieldType() == FieldType.Single)
                builder.append(", #{").append(field.getProperty()).append("}");
            });
            builder.append("</if>");
        });
        
        return builder.toString();
//        String rVal = builder.toString();
//        if(children.values().isEmpty()) {
//            return rVal.substring(0, rVal.length() - 2);
//        } else {
//            return rVal;
//        }
    }
    
    public String getUpdateList() {
        StringBuilder builder = new StringBuilder();
        
        int max = getMaxFieldLength() + 2;
        
        for(Field field : fields) {
            if(field.getFieldType() == FieldType.Single) {
                String prop = field.getProperty();
                if(prop.equals("id")) continue;

                String col = ((SingleField) field).getColumn();
                builder.append("            ").append(Format.cell(col, max))
                        .append("= #{").append(prop).append("},\n");
            }
        }
        
        children.values().forEach( (child) -> { 
            builder.append("\n            <if test=\"_parameter instanceof ").append(child.clazz).append("\">\n");
            child.getFields().forEach( (field) -> {
                String prop = field.getProperty();
                String col = ((SingleField) field).getColumn();
                builder.append("            ").append(Format.cell(col, max))
                        .append("= #{").append(prop).append("},\n");
            });
            builder.replace(builder.length()-2, builder.length(), "");
            builder.append("\n            </if>");
        });
                
        String rVal = builder.toString();
        if(children.values().isEmpty()) {
            return rVal.substring(0, rVal.length() - 2);
        } else {
            return rVal.replace("\n\n", "\n");
        }
    }
    
    public int getMaxFieldLength() {
        int max = 0;
        for(Field field : fields) {  
            if(field.getProperty().length() > max) max = field.getProperty().length();
        }
        return max;
    }
    
    public String getResultMap() {
        return resultMap;
    }

    public void setResultMap(String resultMap) {
        this.resultMap = resultMap;
    }

    public String getMapper() {
        if(mapper == null) {
            return (type == null)? null : type + "Mapper";
        }
        return mapper;
    }
    
    public String getMapperL() {
        return getMapper().substring(0, 1).toLowerCase()
                + (getMapper().length() > 1? getMapper().substring(1):"");
    }

    public void setMapper(String mapper) {
        this.mapper = mapper;
    }
    
    public List<CollectionField> getCollectionFields() {
        ArrayList<CollectionField> cl = new ArrayList<>();
        fields.stream().filter((field) -> (field.getFieldType() == FieldType.Collection)).forEach((field) -> {
            cl.add((CollectionField) field);
        });
        return cl;
    }
    
    public CollectionField getCollectionField(String prop) {
        for(CollectionField cf : getCollectionFields()) {
            if(cf.getProperty().equals(prop)) {
                return cf;
            }
        }
        return null;
    }
    
    public List<AssociationField> getAssociationFields() {
        ArrayList<AssociationField> as = new ArrayList<>();
        fields.stream().filter((field) -> (field.getFieldType() == FieldType.Association)).forEach((field) -> {
            as.add((AssociationField) field);
        });
        return as;
    }
    
    public boolean hasAssociationField() {
        return !getAssociationFields().isEmpty();
    }
    public AssociationField getAssociationField(String prop) {
        for(AssociationField af : getAssociationFields()) {
            if(af.getProperty().equals(prop)) {
                return af;
            }
        }
        return null;
    }
    
    public List<SingleField> getSingleFields() {
        ArrayList<SingleField> sf = new ArrayList<>();
        fields.stream().filter((field) -> (field.getFieldType() == FieldType.Single)).forEach((field) -> {
            sf.add((SingleField) field);
        });
        return sf;
    }
    
    public List<SingleField> getSearchableFields() {
        ArrayList<SingleField> sf = new ArrayList<>();
        fields.stream().filter((field) -> (field.getFieldType() == FieldType.Single 
                && ((SingleField) field).isSearchable())).forEach((field) -> {
            sf.add((SingleField) field);
        });
        return sf;
    }
    
    public boolean hasSearchableFields() {
        return !getSearchableFields().isEmpty();
    }
    
    public List<SingleField> getFindByFields() {
        ArrayList<SingleField> sf = new ArrayList<>();
        fields.stream().filter((field) -> (field.getFieldType() == FieldType.Single
                && ((SingleField) field).isFindBy())).forEach((field) -> {
            sf.add((SingleField) field);
        });
        return sf;
    }
    
    public List<SingleField> getSelectAloneFields() {
        ArrayList<SingleField> sf = new ArrayList<>();
        fields.stream().filter((field) -> (field.getFieldType() == FieldType.Single
                && ((SingleField) field).isSelectAlone())).forEach((field) -> {
            sf.add((SingleField) field);
        });
        return sf;
    }
    
    public boolean hasFindByFields() {
        return !getFindByFields().isEmpty();
    }
    
     public SingleField getField(String prop) {
        ArrayList<SingleField> sf = new ArrayList<>();
        for(Field field : fields) {
            if(field.getFieldType() == FieldType.Single 
                    && prop.equals(((SingleField) field).getProperty())) {
                return (SingleField) field;
            }
        }
        return null;
    }
     
    public boolean is(SingleField field, MetadataType type ) {
        switch(type) {
            case Alone:
                return field.isSelectAlone();
            case FindBy:
                return field.isFindBy();
            case Searchable:
                return field.isSearchable();
            case Unique:
                return field.isUnique();
        }
        return false;
    }
    
    public String getColumn(String property) {
        List<SingleField> sfs = getSingleFields();
        for(SingleField sf : sfs) {
            if(sf.getProperty().equals(property))
                return sf.getColumn();
        }
        return null;
    }
    
    public static List<DObject> of(String str) {
        List<DObject> objs = new ArrayList<>();
        
        String[] lines = str.split("\n");
        
        int i, j;
        String ID   = "id=\"";
        String TYPE = "type=\"";
        String PROP = "property=\"";
        String OFTP = "ofType=\"";
        String COLM = "column=\"";
        String JVTP = "javaType=\"";
        String TBLE = "Table:";
        String FIND = "Find By:";
        String SRCH = "Searchable:";
        String ALON = "Select Alone:";
        String UNIQ = "Unique:";
        String MAPR = "Mapper:";
        String DBO  = "DBO:";
        String FKEY = "FK:";
        String JTYP = "Type:";
        String CASE = "<case";
        String RSMP = "resultMap=\"";
        String CLAZ = "Class:";
        
        DObject obj = null;
        CollectionField  collection  = null;
        AssociationField association = null;
        for(String line : lines) {
            line = line.trim();
            if(line.isEmpty()) continue;
            
            if(line.contains("<resultMap")) {
                i = line.indexOf(ID);
                j = line.indexOf("\"", i + ID.length());
                String id = line.substring(i + ID.length(), j).trim();
                
                i = line.indexOf(TYPE);
                j = line.indexOf("\"", i + TYPE.length());
                String type = line.substring(i + TYPE.length(), j).trim();
                
                obj = new DObject(id, type);
                obj.setResultMap(id);
            }
            
            if(line.startsWith(TBLE)) {
                String table = line.substring(TBLE.length()).trim();
                obj.setTable(table);
            }
            
            if(line.startsWith(CLAZ)) {
                String clazz = line.substring(CLAZ.length()).trim();
                obj.setClazz(clazz);
            }
            
            if(line.startsWith(DBO)) {
                String dbo = line.substring(DBO.length()).trim();
                obj.setDbo(dbo);
            }
            
            if(line.startsWith(MAPR)) {
                String mapper = line.substring(MAPR.length()).trim();
                obj.setMapper(mapper);
            }
            
            if(line.startsWith(FIND)) {
                String findByStr = line.substring(FIND.length()).trim();
                String[] findByList = findByStr.split(",");
                for(String findByCol: findByList) {
                    findByCol = findByCol.trim();
                    for(Field field : obj.fields) {
                        if(field.getFieldType() == FieldType.Single
                                && ((SingleField) field).getColumn().equals(findByCol)) {
                            ((SingleField) field).setFindBy(true);
                        }
                    }
                }
            }
            
            if(line.startsWith(SRCH)) {
                String searchableStr = line.substring(SRCH.length()).trim();
                String[] searchableList = searchableStr.split(",");
                for(String searchableCol: searchableList) {
                    searchableCol = searchableCol.trim();
                    for(Field field : obj.fields) {
                        if(field.getFieldType() == FieldType.Single
                                && ((SingleField) field).getColumn().equals(searchableCol)) {
                            ((SingleField) field).setSearchable(true);
                        }
                    }
                }
            }
            
            if(line.startsWith(ALON)) {
                String selAloneStr = line.substring(ALON.length()).trim();
                String[] selAloneList = selAloneStr.split(",");
                for(String selAloneCol: selAloneList) {
                    selAloneCol = selAloneCol.trim();
                    for(Field field : obj.fields) {
                        if(field.getFieldType() == FieldType.Single
                                && ((SingleField) field).getColumn().equals(selAloneCol)) {
                            ((SingleField) field).setSelectAlone(true);
                        }
                    }
                }
            }
            
            if(line.startsWith(UNIQ)) {
                String uniqueStr = line.substring(UNIQ.length()).trim();
                String[] uniqueList = uniqueStr.split(",");
                for(String uniqueCol: uniqueList) {
                    uniqueCol = uniqueCol.trim();
                    for(Field field : obj.fields) {
                        if(field.getFieldType() == FieldType.Single
                                && ((SingleField) field).getColumn().equals(uniqueCol)) {
                            ((SingleField) field).setUnique(true);
                        }
                    }
                }
            }
            
            if(line.startsWith(FKEY)) {
                String fKeyStr = line.substring(FKEY.length()).trim();
                String[] fKeyList = fKeyStr.split(",");
                CollectionField cf;
                if(fKeyList.length == 2 && 
                        ((cf = obj.getCollectionField(fKeyList[0].trim())) != null)) {
                    cf.setFKey(fKeyList[1].trim());
                }
            }
            
            if(line.startsWith(JTYP)) {
                String typesStr = line.substring(JTYP.length()).trim();
                String[] typesList = typesStr.split(";");
                for(String type : typesList) {
                    String[] split = type.split(" ");
                    String javaType = null;
                    List<String> vars = new ArrayList<>();
                    for(int k = 0; k < split.length; k++) {
                        if(split[k].trim().isEmpty())
                            continue;
                        if(javaType == null) {
                            javaType = split[k].trim();
                            continue;
                        }
                        vars.add(split[k].replace(",","").trim());
                    }
                    
                    for(String var : vars) { 
                        for(Field field : obj.fields) {
                            if(field.getProperty().equals(var)) {
                                field.setJavaType(javaType);
                            }
                        }
                    
                    }
                }
            }
            
            if(line.startsWith(CASE)) {
                i = line.indexOf(RSMP);
                j = line.indexOf("\"", i + RSMP.length());
                String resultMap = line.substring(i + RSMP.length(), j).trim();
                //Need to add DObject at the end once we are sure it ready.
                obj.children.put(resultMap, null);
            }
            
            if(line.contains(PROP) && line.contains(COLM) && !line.contains("<association")) {
                i = line.indexOf(PROP);
                j = line.indexOf("\"", i + PROP.length());
                String prop = line.substring(i + PROP.length(), j).trim();

                i = line.indexOf(COLM);
                j = line.indexOf("\"", i + COLM.length());
                String col = line.substring(i + COLM.length(), j).trim();

                if(association != null) {
                    association.addField(prop, col);
                } else if(collection != null) {
                    collection.addField(prop, col);
                } else {
                    SingleField field = new SingleField(prop, col); 
                    obj.fields.add( field );
                    if(line.trim().startsWith("<id"))
                        obj.idField = field;
                }
                
                
            }
            
            if(line.contains("</resultMap>")) {
                objs.add(obj);
            }
                    
            if(line.contains("<collection")) {
                collection = new CollectionField();
        
                i = line.indexOf(PROP);
                j = line.indexOf("\"", i + PROP.length());
                String prop = line.substring(i + PROP.length(), j).trim();
                collection.setProperty(prop);
                
                i = line.indexOf(OFTP);
                j = line.indexOf("\"", i + OFTP.length());
                String oftype = line.substring(i + OFTP.length(), j).trim();
                collection.setType(oftype);
                obj.fields.add(collection);
            }
            
            if(line.contains("</collection>")) {
                collection = null;
            }
            
                    
            if(line.contains("<association")) {
                association = new AssociationField();
        
                i = line.indexOf(PROP);
                j = line.indexOf("\"", i + PROP.length());
                String prop = line.substring(i + PROP.length(), j).trim();
                association.setProperty(prop);
                
                i = line.indexOf(COLM);
                j = line.indexOf("\"", i + COLM.length());
                String col = line.substring(i + COLM.length(), j).trim();
                association.setColumn(col);
                
                i = line.indexOf(JVTP);
                j = line.indexOf("\"", i + JVTP.length());
                String javaType = line.substring(i + JVTP.length(), j).trim();
                association.setJavaType(javaType);
                
                obj.fields.add(association);
            }
            
            if(line.contains("</association>")) {
                association = null;
            }
        }
        
        
        //Setting up Collections
        objs.stream().forEach((DObject dObj) -> {
            dObj.getAssociationFields().stream().forEach((field) -> {
                for (DObject dObj2 : objs) {
                    if(field.getJavaType().equals(dObj2.getType()))
                        field.setdObj(dObj2);
                }
                if(field.getdObj() == null) {
                    throw new RuntimeException("Association [" 
                            + field.getProperty() + "] in [" 
                            + dObj.getTable() + "] table requries Type ["
                            + field.getJavaType() + "]");
                }
            });
            
            dObj.getCollectionFields().stream().forEach((field) -> {
                for (DObject dObj2 : objs) {
                    if(field.getType().equals(dObj2.getType()))
                        field.setdObj(dObj2);
                }
                if(field.getdObj() == null) {
                    throw new RuntimeException("Collection [" 
                            + field.getProperty() + "] in " 
                            + dObj.getTable() + " requries Type ["
                            + field.getType() + "]");
                }
            });
            
            dObj.children.keySet().stream().forEach((resultMap) -> {
                for (DObject dObj2 : objs) {
                    if(resultMap.equals(dObj2.getResultMap()))
                        dObj.children.put(resultMap, dObj2);
                }
                if(dObj.children.get(resultMap) == null) {
                    throw new RuntimeException("case with ResultMap [" 
                            + resultMap + "] is null");
                }
            });
        });
        
        return objs;
    }

    @Override
    public String toString() {
        return "DObject{" + "table=" + table + ", type=" + type + ", resultMap=" + resultMap + ", mapper=" + mapper + ", fields=" + fields + '}';
    }

    private boolean hasCollections() {
        return !getCollectionFields().isEmpty();
    }
    
    // ture -> no need for findDBO(Dbo dbo)
    public boolean isSearchableUnique() {
        for( SingleField sField : getSearchableFields()) { 
            if(!is( sField, MetadataType.Unique))
                return false;
        }
        return true;
    }

}

*** end *** end ***
***$$$@@@ /src/main/java/com/almatarm/mybatishelper/FieldType.java
package com.almatarm.mybatishelper;

/**
 *
 * @author almatarm
 */
public enum FieldType {
    Single,
    Collection,
    Association;
}

*** end *** end ***
***$$$@@@ /src/main/java/com/almatarm/mybatishelper/Gen.form
<?xml version="1.0" encoding="UTF-8" ?>

<Form version="1.3" maxVersion="1.9" type="org.netbeans.modules.form.forminfo.JFrameFormInfo">
  <NonVisualComponents>
    <Menu class="javax.swing.JMenuBar" name="menuBar">
      <SubComponents>
        <Menu class="javax.swing.JMenu" name="fileMenu">
          <Properties>
            <Property name="mnemonic" type="int" value="102"/>
            <Property name="text" type="java.lang.String" value="File"/>
          </Properties>
          <SubComponents>
            <MenuItem class="javax.swing.JMenuItem" name="openMenuItem">
              <Properties>
                <Property name="mnemonic" type="int" value="111"/>
                <Property name="text" type="java.lang.String" value="Open"/>
              </Properties>
            </MenuItem>
            <MenuItem class="javax.swing.JMenuItem" name="saveMenuItem">
              <Properties>
                <Property name="mnemonic" type="int" value="115"/>
                <Property name="text" type="java.lang.String" value="Save"/>
              </Properties>
            </MenuItem>
            <MenuItem class="javax.swing.JMenuItem" name="saveAsMenuItem">
              <Properties>
                <Property name="mnemonic" type="int" value="97"/>
                <Property name="text" type="java.lang.String" value="Save As ..."/>
                <Property name="displayedMnemonicIndex" type="int" value="5"/>
              </Properties>
            </MenuItem>
            <MenuItem class="javax.swing.JMenuItem" name="exitMenuItem">
              <Properties>
                <Property name="mnemonic" type="int" value="120"/>
                <Property name="text" type="java.lang.String" value="Exit"/>
              </Properties>
              <Events>
                <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="exitMenuItemActionPerformed"/>
              </Events>
            </MenuItem>
          </SubComponents>
        </Menu>
        <Menu class="javax.swing.JMenu" name="editMenu">
          <Properties>
            <Property name="mnemonic" type="int" value="101"/>
            <Property name="text" type="java.lang.String" value="Edit"/>
          </Properties>
          <SubComponents>
            <MenuItem class="javax.swing.JMenuItem" name="cutMenuItem">
              <Properties>
                <Property name="mnemonic" type="int" value="116"/>
                <Property name="text" type="java.lang.String" value="Cut"/>
              </Properties>
            </MenuItem>
            <MenuItem class="javax.swing.JMenuItem" name="copyMenuItem">
              <Properties>
                <Property name="mnemonic" type="int" value="121"/>
                <Property name="text" type="java.lang.String" value="Copy"/>
              </Properties>
            </MenuItem>
            <MenuItem class="javax.swing.JMenuItem" name="pasteMenuItem">
              <Properties>
                <Property name="mnemonic" type="int" value="112"/>
                <Property name="text" type="java.lang.String" value="Paste"/>
              </Properties>
            </MenuItem>
            <MenuItem class="javax.swing.JMenuItem" name="deleteMenuItem">
              <Properties>
                <Property name="mnemonic" type="int" value="100"/>
                <Property name="text" type="java.lang.String" value="Delete"/>
              </Properties>
            </MenuItem>
          </SubComponents>
        </Menu>
        <Menu class="javax.swing.JMenu" name="helpMenu">
          <Properties>
            <Property name="mnemonic" type="int" value="104"/>
            <Property name="text" type="java.lang.String" value="Help"/>
          </Properties>
          <SubComponents>
            <MenuItem class="javax.swing.JMenuItem" name="contentsMenuItem">
              <Properties>
                <Property name="mnemonic" type="int" value="99"/>
                <Property name="text" type="java.lang.String" value="Contents"/>
              </Properties>
            </MenuItem>
            <MenuItem class="javax.swing.JMenuItem" name="aboutMenuItem">
              <Properties>
                <Property name="mnemonic" type="int" value="97"/>
                <Property name="text" type="java.lang.String" value="About"/>
              </Properties>
            </MenuItem>
          </SubComponents>
        </Menu>
      </SubComponents>
    </Menu>
  </NonVisualComponents>
  <Properties>
    <Property name="defaultCloseOperation" type="int" value="3"/>
  </Properties>
  <SyntheticProperties>
    <SyntheticProperty name="menuBar" type="java.lang.String" value="menuBar"/>
    <SyntheticProperty name="formSizePolicy" type="int" value="1"/>
    <SyntheticProperty name="generateCenter" type="boolean" value="false"/>
  </SyntheticProperties>
  <AuxValues>
    <AuxValue name="FormSettings_autoResourcing" type="java.lang.Integer" value="0"/>
    <AuxValue name="FormSettings_autoSetComponentName" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_generateFQN" type="java.lang.Boolean" value="true"/>
    <AuxValue name="FormSettings_generateMnemonicsCode" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_i18nAutoMode" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_layoutCodeTarget" type="java.lang.Integer" value="1"/>
    <AuxValue name="FormSettings_listenerGenerationStyle" type="java.lang.Integer" value="0"/>
    <AuxValue name="FormSettings_variablesLocal" type="java.lang.Boolean" value="false"/>
    <AuxValue name="FormSettings_variablesModifier" type="java.lang.Integer" value="2"/>
  </AuxValues>

  <Layout>
    <DimensionLayout dim="0">
      <Group type="103" groupAlignment="0" attributes="0">
          <Group type="102" attributes="0">
              <Group type="103" groupAlignment="0" attributes="0">
                  <Group type="102" attributes="0">
                      <EmptySpace min="-2" pref="10" max="-2" attributes="0"/>
                      <Component id="jScrollPane3" max="32767" attributes="0"/>
                  </Group>
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane4" max="32767" attributes="0"/>
                  </Group>
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="javaType" min="-2" pref="170" max="-2" attributes="0"/>
                      <EmptySpace type="unrelated" max="-2" attributes="0"/>
                      <Component id="sqlTable" min="-2" pref="173" max="-2" attributes="0"/>
                      <EmptySpace pref="190" max="32767" attributes="0"/>
                      <Component id="jComboBox1" min="-2" pref="264" max="-2" attributes="0"/>
                      <EmptySpace type="separate" max="-2" attributes="0"/>
                      <Component id="generate" min="-2" max="-2" attributes="0"/>
                  </Group>
                  <Group type="102" alignment="0" attributes="0">
                      <EmptySpace max="-2" attributes="0"/>
                      <Component id="jScrollPane1" max="32767" attributes="0"/>
                  </Group>
              </Group>
              <EmptySpace max="-2" attributes="0"/>
          </Group>
      </Group>
    </DimensionLayout>
    <DimensionLayout dim="1">
      <Group type="103" groupAlignment="0" attributes="0">
          <Group type="102" alignment="0" attributes="0">
              <EmptySpace min="-2" pref="10" max="-2" attributes="0"/>
              <Component id="jScrollPane3" min="-2" pref="153" max="-2" attributes="0"/>
              <EmptySpace max="-2" attributes="0"/>
              <Component id="jScrollPane1" min="-2" pref="173" max="-2" attributes="0"/>
              <EmptySpace max="-2" attributes="0"/>
              <Component id="jScrollPane4" min="-2" pref="216" max="-2" attributes="0"/>
              <EmptySpace type="separate" max="-2" attributes="0"/>
              <Group type="103" groupAlignment="3" attributes="0">
                  <Component id="jComboBox1" alignment="3" min="-2" max="-2" attributes="0"/>
                  <Component id="generate" alignment="3" min="-2" max="-2" attributes="0"/>
                  <Component id="javaType" alignment="3" min="-2" max="-2" attributes="0"/>
                  <Component id="sqlTable" alignment="3" min="-2" max="-2" attributes="0"/>
              </Group>
              <EmptySpace max="32767" attributes="0"/>
          </Group>
      </Group>
    </DimensionLayout>
  </Layout>
  <SubComponents>
    <Container class="javax.swing.JScrollPane" name="jScrollPane3">
      <AuxValues>
        <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
      </AuxValues>

      <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
      <SubComponents>
        <Component class="javax.swing.JTextArea" name="in">
          <Properties>
            <Property name="columns" type="int" value="20"/>
            <Property name="rows" type="int" value="5"/>
            <Property name="text" type="java.lang.String" value="        &lt;id     property=&quot;id&quot;             column=&quot;ID&quot; /&gt;&#xa;        &lt;result property=&quot;code&quot;           column=&quot;Code&quot; /&gt;&#xa;        &lt;result property=&quot;description&quot;    column=&quot;Descr&quot; /&gt;&#xa;        &lt;result property=&quot;symbol&quot;         column=&quot;Symbol&quot; /&gt;&#xa;        &lt;result property=&quot;provider&quot;       column=&quot;Provider&quot; /&gt;&#xa;        &lt;result property=&quot;fractionDigits&quot; column=&quot;FractDigt&quot; /&gt;"/>
          </Properties>
        </Component>
      </SubComponents>
    </Container>
    <Container class="javax.swing.JScrollPane" name="jScrollPane4">
      <AuxValues>
        <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
      </AuxValues>

      <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
      <SubComponents>
        <Component class="javax.swing.JTextArea" name="out">
          <Properties>
            <Property name="columns" type="int" value="20"/>
            <Property name="rows" type="int" value="5"/>
          </Properties>
        </Component>
      </SubComponents>
    </Container>
    <Component class="javax.swing.JComboBox" name="jComboBox1">
      <Properties>
        <Property name="model" type="javax.swing.ComboBoxModel" editor="org.netbeans.modules.form.editors2.ComboBoxModelEditor">
          <StringArray count="4">
            <StringItem index="0" value="Item 1"/>
            <StringItem index="1" value="Item 2"/>
            <StringItem index="2" value="Item 3"/>
            <StringItem index="3" value="Item 4"/>
          </StringArray>
        </Property>
      </Properties>
      <AuxValues>
        <AuxValue name="JavaCodeGenerator_TypeParameters" type="java.lang.String" value="&lt;String&gt;"/>
      </AuxValues>
    </Component>
    <Component class="javax.swing.JButton" name="generate">
      <Properties>
        <Property name="text" type="java.lang.String" value="Generate"/>
      </Properties>
      <Events>
        <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="generateActionPerformed"/>
      </Events>
    </Component>
    <Component class="javax.swing.JTextField" name="javaType">
      <Properties>
        <Property name="text" type="java.lang.String" value="java"/>
      </Properties>
    </Component>
    <Component class="javax.swing.JTextField" name="sqlTable">
      <Properties>
        <Property name="text" type="java.lang.String" value="table"/>
      </Properties>
    </Component>
    <Container class="javax.swing.JScrollPane" name="jScrollPane1">
      <AuxValues>
        <AuxValue name="autoScrollPane" type="java.lang.Boolean" value="true"/>
      </AuxValues>

      <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
      <SubComponents>
        <Component class="javax.swing.JTextArea" name="methods">
          <Properties>
            <Property name="columns" type="int" value="20"/>
            <Property name="rows" type="int" value="5"/>
          </Properties>
        </Component>
      </SubComponents>
    </Container>
  </SubComponents>
</Form>

*** end *** end ***
***$$$@@@ /src/main/java/com/almatarm/mybatishelper/CodeGen.java
/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.almatarm.mybatishelper;

/**
 *
 * @author almatarm
 */
public class CodeGen extends javax.swing.JFrame {

    /**
     * Creates new form CodeGen
     */
    public CodeGen() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jSeparator1 = new javax.swing.JSeparator();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        getContentPane().add(jSeparator1, java.awt.BorderLayout.CENTER);

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        getContentPane().add(jScrollPane1, java.awt.BorderLayout.PAGE_START);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(CodeGen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(CodeGen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(CodeGen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(CodeGen.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new CodeGen().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JTextArea jTextArea1;
    // End of variables declaration//GEN-END:variables
}

*** end *** end ***
***$$$@@@ /src/main/java/com/almatarm/mybatishelper/GenOutput.java
package com.almatarm.mybatishelper;

import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.exception.MethodInvocationException;
import org.apache.velocity.exception.ParseErrorException;
import org.apache.velocity.exception.ResourceNotFoundException;
import org.jvnet.inflector.Noun;

/**
 *
 * @author <a href="mailto:almatarm@gmail.com">Mufeed H. AlMatar</a>
 * @version 1.0
 */
public class GenOutput {
    HashMap<String, DObject> objects;// = new HashMap<>();
    List<Method> methods;// = new ArrayList<>();
    boolean useSpring = false;
    
    public GenOutput(HashMap<String, DObject> objects, List<Method> methods) {
        this.objects = objects;
        this.methods = methods;
    }
    
    public GenOutput(HashMap<String, DObject> objects) {
        this.objects = objects;
    }

    public boolean isUseSpring() {
        return useSpring;
    }

    public void setUseSpring(boolean useSpring) {
        this.useSpring = useSpring;
    }
    
    public String generate() {
        StringBuilder buff = new StringBuilder();
        
        methods.forEach( (method) -> { 
//            switch (method)
            System.out.println("M" + method);
        });
                
        return buff.toString();
    }
    
    public void genService(DObject dObj) {
        genService(dObj, "Service");
        System.out.println("**************************************************");
        if(!useSpring) 
            genService(dObj, "mybatis-service");
    }
    
    public void genService(DObject dObj, String template) {
        try {
            String Dbo  = dObj.getDbo();
            String Dbos = Noun.pluralOf(Dbo);
            String dbo  = Dbo.length() > 1 ? Dbo.substring(0, 1).toLowerCase() 
                    + Dbo.substring(1): Dbo.toLowerCase();
            
            Reader reader = new InputStreamReader(GenOutput.class.getClassLoader()
                    .getResourceAsStream(template));
            VelocityContext context = new VelocityContext();
//            context.put("disp",  new DisplayTool());
            context.put("Noun", Noun.class);
            context.put("Util", Util.class);
            context.put("dObj", dObj);
            context.put("Dbo",  Dbo);
            context.put("Dbos", Dbos);
            context.put("dbo",  dbo);
            
            context.put("Table", dObj.getTable());
            context.put("Type", dObj.getType());
            context.put("ResultMap", dObj.getResultMap());
            context.put("ColumnsList", dObj.getColumnsList());
            context.put("ColumnsListNoID", dObj.getColumnsList().replace("ID, ", ""));
            
            context.put("PropListInsert", dObj.getPropListInsert());
            context.put("PropListInsertNoID", dObj.getPropListInsert().replace("#{id}, ", ""));
            
            context.put("UpdateList", dObj.getUpdateList());
            
            context.put("new_line", "\n");
            
            context.put("use_spring", useSpring);
            StringWriter writer = new StringWriter();
            Velocity.evaluate(context, writer, "", reader);
            
            System.out.println(writer.toString().replaceAll("\n\\s*\n+", "\n\n"));
        } catch (ParseErrorException | MethodInvocationException | ResourceNotFoundException ex) {
            Logger.getLogger(GenOutput.class.getName()).log(Level.SEVERE, null, ex);
        }

    }
    
    public static void main(String args[]) {
        HashMap<String, DObject> objects = new HashMap<>();
        List<Method> methods = new ArrayList<>();
        
        String tagsStr = "\n" +
"    <resultMap  id=\"tagGroupResultMap\"   type=\"TagGroup\">\n" +
"        <id         property=\"id\"       column=\"ID\" />\n" +
"        <result     property=\"name\"     column=\"Name\" />       \n" +
"        <collection property=\"tags\"     ofType=\"Tag\" > \n" +
"            <id     property=\"id\"       column=\"Tag_ID\" />      \n" +
"            <result property=\"name\"     column=\"Tag_Name\" />   \n" +
"        </collection>\n" +
"        <!-- \n" +
"            Table: TagGroup\n" +
"            Mapper: TagMapper\n" +
"            Unique: ID, Name\n" +
"            Find By: ID, Name\n" +
"            Searchable: Name\n" +
"            Select Alone: Name\n" +
"            FK: tags, TagGroup_ID\n" +
"            Type: Long id; String name; Tag tags; \n" +           
"        -->\n" +
"    </resultMap>\n" +
"    \n" +
"    <resultMap  id=\"tagResultMap\"   type=\"Tag\">\n" +
"        <id     property=\"id\"       column=\"ID\" />\n" +
"        <result property=\"name\"     column=\"Name\" />           \n" +
"        <!-- \n" +
"            Table: Tag \n" +
"            Unique: ID\n" +
"            Find By: ID, Name\n" +
"            Searchable: Name\n" +
"            Type: Long ID; String Name; \n" +           
"        -->   \n" +
"    </resultMap>\n" + 
"    <resultMap  id=\"payeeResultMap\"   type=\"Payee\">\n" +
"        <id     property=\"id\"         column=\"ID\" />\n" +
"        <result property=\"name\"       column=\"Name\" />\n" +
"        <result property=\"address\"    column=\"Address\" />\n" +
"        <!-- \n" +
"            Table: Payee\n" +
"            Mapper: PayeeMapper\n" +
"            Unique: ID, Name\n" +
"            Find By: ID, Name\n" +
"            Searchable: Name, Address\n" +
"            Select Alone: Name\n" +
"            Type: Long id; String name, address; \n" +
"        -->\n" +
"    </resultMap>\n" +
"    <resultMap  id=\"currencyUnitResultMap\"   type=\"CurrencyUnitDO\">\n" +
"        <id     property=\"id\"             column=\"ID\" />\n" +
"        <result property=\"code\"           column=\"Code\" />\n" +
"        <result property=\"description\"    column=\"Descr\" />\n" +
"        <result property=\"symbol\"         column=\"Symbol\" />\n" +
"        <result property=\"provider\"       column=\"Provider\" />\n" +
"        <result property=\"fractionDigits\" column=\"FractDigt\" />\n" +
"        <!-- \n" +
"            Table: Currency\n" +
"            DBO: CurrencyUnit\n" +
"            Mapper: currencyMapper\n" +
"            Unique: ID, Code\n" +
"            Find By: ID, Name, Descr, Symbol, Provider\n" +
"            Searchable: Code, Descr, Symbol, Provider\n" +
"            Select Alone: Code, Provider\n" +
"            Type: Long id; \n" +
"        -->\n" +
"    </resultMap>\n" +
"    <resultMap  id=\"transactionResultMap\"   type=\"Transaction\">\n" +
"        <id         property=\"id\"                 column=\"ID\" />\n" +
"        <result     property=\"date\"               column=\"Date\" />       \n" +
"        <result     property=\"effectiveDate\"      column=\"EffectiveDate\" />       \n" +
"        <result     property=\"amount\"             column=\"Amount\" />       \n" +
"        <result     property=\"number\"             column=\"Number\" />       \n" +  
"        <result     property=\"memo\"               column=\"Memo\" />       \n" +                  
"        <result     property=\"status\"             column=\"Status\" />       \n" +
"        <result     property=\"payeeID\"            column=\"Payee_ID\" />\n" +
"        <result     property=\"accountID\"          column=\"Account_ID\" /> \n" +
"        <result     property=\"transactionGroupID\" column=\"TGroup_ID\" /> \n" +
"        <result     property=\"type\"               column=\"Type\" />       \n" + 
"        <collection property=\"tags\"     ofType=\"Tag\" > \n" +
"            <id     property=\"id\"       column=\"Tag_ID\" />      \n" +
"            <result property=\"name\"     column=\"Tag_Name\" />   \n" +
"        </collection>\n" +
"        \n" +
"        <!-- \n" +
"            Table: Transactions\n" +
"            Mapper: TransactionMapper\n" +
"            Unique: ID\n" +
"            Find By: ID, Date, EffectiveDate, Number, Memo, Status\n" +
"            Searchable: Name, Date, EffectiveDate, Number, Memo, Status\n" +
"            !Select Alone: \n" +
"            !FK: tags, TagGroup_ID\n" +
"            Type: Long id, payeeID, accountID, transactionGropuID;\n" +
"            Type: TransactionStatus status;\n" +
"            Type: Calendar date, effectiveDate;\n" +
"            Type: TransactionType type;\n" +
"            Type: String number, memo;\n" +
"        -->\n" +
"    </resultMap>\n" + 
"    <resultMap  id=\"accountResultMap\"    type=\"Account\">\n" +
"        <id     property=\"id\"            column=\"ID\" />\n" +
"        <result property=\"name\"          column=\"Name\" />\n" +
"        <result property=\"description\"   column=\"Descr\" />\n" +
"        <result property=\"notes\"         column=\"Notes\" />\n" +
"        <result property=\"type\"          column=\"Type\" />\n" +
"        <result property=\"parentID\"      column=\"Parent_ID\" />\n" +
"        <result property=\"hidden\"        column=\"Hidden\" />\n" +
"        <result property=\"qualifiedName\" column=\"QName\" />\n" +
"        <association property=\"currency\"     column=\"Currency_ID\" javaType=\"CurrencyUnitDO\">\n" +
"            <id     property=\"id\"             column=\"CU_ID\" />\n" +
"            <result property=\"code\"           column=\"CU_Code\" />\n" +
"            <result property=\"description\"    column=\"CU_Descr\" />\n" +
"            <result property=\"symbol\"         column=\"CU_Symbol\" />\n" +
"            <result property=\"provider\"       column=\"CU_Provider\" />\n" +
"            <result property=\"fractionDigits\" column=\"CU_FractDigt\" />\n" +
"        </association>\n" +
"        <discriminator column=\"Type\" javaType=\"AccountType\">\n" +
"            <case value=\"CREDIT\" resultMap=\"creditResultMap\" />\n" +
"            <case value=\"LOAN\"   resultMap=\"loanResultMap\" />            \n" +
"        </discriminator>\n" +
"        <!-- \n" +
"            Table: Account\n" +
"            Mapper: AccountMapper\n" +
"            Unique: ID, QName\n" +
"            Find By: ID, QName, Name, Parent_ID\n" +
"            Searchable: Name, Descr, Notes, Type, QName\n" +
"            !Select Alone: \n" +
"            !FK: currency, TagGroup_ID\n" +
"            Type: Long id, parentID; String name, qualifiedName, description, notes;\n" +
"            Type: String name, qualifiedName, description, notes;\n" +
"            Type: boolean hidden;\n" +
"        -->\n" +
"    </resultMap>\n" +
"\n" +
"    <resultMap  id=\"creditResultMap\" type=\"CreditAccount\" extends=\"accountResultMap\">\n" +
"        <result property=\"limit\"            column=\"CreditLimit\" />\n" +
"        <result property=\"statementDay\"     column=\"StatDay\" />\n" +
"        <!-- \n" +
"            Type: BigDecimal limit; int statementDay;\n" +
"            Class: com.almatarm.money.domain.CreditAccount\n" +
"        -->\n" +
"    </resultMap>\n" +
"    \n" +
"    <resultMap  id=\"loanResultMap\" type=\"Loan\" extends=\"accountResultMap\">\n" +
"        <result property=\"presentValue\"     column=\"PresentValue\" />\n" +
"        <result property=\"interestRate\"     column=\"InterestRate\" />\n" +
"        <!-- \n" +
"            Type: BigDecimal presentValue, interestRate;\n" +
"            Class: com.almatarm.money.domain.Loan\n" +
"        -->\n" +
"    </resultMap>\n" +
"    <resultMap type=\"User\" id=\"UserResult\">\n" +
"      <id property=\"userId\" column=\"user_id\"/>\n" +
"      <result property=\"emailId\" column=\"email_id\"/>\n" +
"      <result property=\"password\" column=\"password\"/>\n" +
"      <result property=\"firstName\" column=\"first_name\"/>\n" +
"      <result property=\"lastName\" column=\"last_name\"/>   \n" +
"   </resultMap>";
        /*
        String payeeMethods = "" +
"    public List<Payee> getPayees();\n" +
"\n" +
"    public Payee findPayeeByID(Long id);\n" +
"\n" +
"    public Payee findPayeeByName(String name);\n" +
"\n" +
"    public List<Payee> findPayeeByNameRegEx(String name);\n" +
"\n" +
"    public void insertPayee(Payee payee);\n" +
"\n" +
"    public void updatePayee(Payee payee);\n" +
"\n" +                
"    public void deletePayee(Long id);" +                
"";
        
        System.out.println(payeeStr);
        System.out.println("------------------------------------------------------------------------");
        System.out.println(payeeMethods);
        System.out.println("------------------------------------------------------------------------");
        */
        
        System.out.println(tagsStr);
        System.out.println("------------------------------------------------------------------------");

        List<DObject> objs = DObject.of(tagsStr);
        objs.stream().forEach( (obj) -> { 
            System.out.println(obj);
        });
        
//        String[] lines = payeeMethods.split("\n");
//        for(String line : lines) {
//            if(!line.trim().isEmpty()) {
//                methods.add(Method.of(line));
//            }
//        }
//        methods.forEach( (m) -> {
//            System.out.println(m);
//        });
//      
        System.out.println("------------------------------------------------------------------------");

        GenOutput go = new GenOutput(objects);
//        System.out.println(go.generate());

//        System.out.println("------------------------------------------------------------------------");
//
        

        go.genService(objs.get(0));
        
        go.genService(objs.get(1));
        
        go.genService(objs.get(3));
        
        
        go.genService(objs.get(5));
//
//        System.out.println("------------------------------------------------------------------------");
//
//        System.out.println(objs.get(0).getColumnsList());
    }
    
}

*** end *** end ***
***$$$@@@ /src/main/java/com/almatarm/mybatishelper/AssociationField.java
package com.almatarm.mybatishelper;

import java.util.LinkedHashMap;

/**
 *
 * @author almatarm
 */
public class AssociationField extends Field {
    String column;
    DObject dObj;
    String fKey;
    LinkedHashMap<String, String> fields = new LinkedHashMap<>();

    public AssociationField() {
        super("Property");
        fieldType = FieldType.Association;
    }

    public AssociationField(String property, String column, String javaType) {
        super(property);
        this.column = column;
        this.javaType = javaType;
    }

    public String getColumn() {
        return column;
    }

    public void setColumn(String column) {
        this.column = column;
    }
    
    public LinkedHashMap<String, String> getFields() {
        return fields;
    }

    public void setFields(LinkedHashMap<String, String> fields) {
        this.fields = fields;
    }
    
    public void addField(String property, String column) {
        fields.put(property, column);
    }
    
    public String getField(String property) {
        return fields.get(property);
    }

    public DObject getdObj() {
        return dObj;
    }

    public void setdObj(DObject dObj) {
        this.dObj = dObj;
    }

    public String getQualifedColumnsList() {
        StringBuilder builder = new StringBuilder();
        
        int max = (int) (getMaxFieldLength() * 1.5);
        fields.keySet().forEach( (prop) -> {
            builder.append("            ").append(dObj.getTable()).append(".")
                    .append(Format.cell(dObj.getColumn(prop), max))    
                    .append(" AS ").append(fields.get(prop)).append(",\n");
        });
        
        String rVal = builder.toString();
        return rVal.substring(0, rVal.length() - 2);
    }
    
    public int getMaxFieldLength() {
        int max = 0;
        for(String prop : fields.keySet()) {  
            if(prop.length() > max) max = prop.length();
        }
        return max;
    }

    @Override
    public String toString() {
        return "AssociationField{" + "column=" + column + ", dObj=" + dObj + ", fKey=" + fKey + ", fields=" + fields + '}';
    }
    
    void setFKey(String fKey) {
        this.fKey = fKey;
    }

    public String getfKey() {
        return fKey;
    }
    
}

*** end *** end ***
***$$$@@@ /src/main/java/com/almatarm/mybatishelper/Field.java
package com.almatarm.mybatishelper;


/**
 *
 * @author almatarm
 */
public class Field {
    
    String property;
    FieldType fieldType;
    String javaType = "String";

    public Field(String property) {
        this.property = property;
    }

    public String getProperty() {
        return property;
    }

    public void setProperty(String property) {
        this.property = property;
    }

    public FieldType getFieldType() {
        return fieldType;
    }

    public String getJavaType() {
        return javaType;
    }

    public void setJavaType(String javaType) {
        this.javaType = javaType;
    }
    
    public String getPropertyU() {
        if(property.equals("id")) return "ID";
        return property.substring(0, 1).toUpperCase() 
                + (property.length() > 1? property.substring(1):"");
    }

}

*** end *** end ***
***$$$@@@ /src/main/java/com/almatarm/mybatishelper/CollectionField.java
package com.almatarm.mybatishelper;

import java.util.LinkedHashMap;

/**
 *
 * @author almatarm
 */
public class CollectionField extends Field {
    String type;
    DObject dObj;
    String fKey;
    LinkedHashMap<String, String> fields = new LinkedHashMap<>();

    public CollectionField() {
        super("Property");
        fieldType = FieldType.Collection;
    }
    
    public CollectionField(String property, String type) {
        super(property);
        this.type = type;
        fieldType = FieldType.Collection;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public LinkedHashMap<String, String> getFields() {
        return fields;
    }

    public void setFields(LinkedHashMap<String, String> fields) {
        this.fields = fields;
    }
    
    public void addField(String property, String column) {
        fields.put(property, column);
    }
    
    public String getField(String property) {
        return fields.get(property);
    }

    public DObject getdObj() {
        return dObj;
    }

    public void setdObj(DObject dObj) {
        this.dObj = dObj;
    }

    public String getQualifedColumnsList() {
        StringBuilder builder = new StringBuilder();
        
        int max = dObj.getMaxFieldLength()  * 3;
        fields.keySet().forEach( (prop) -> {
            builder.append("            ").append(dObj.getTable()).append(".")
                    .append(Format.cell(dObj.getColumn(prop), max))    
                    .append(" AS ").append(fields.get(prop)).append(",\n");
        });
        
        String rVal = builder.toString();
        return rVal.substring(0, rVal.length() - 2);
    }
    
    @Override
    public String toString() {
        return "CollectionField{" + "property=" + property + ", type=" + type + ", fields=" + fields + '}';
    }

    void setFKey(String fKey) {
        this.fKey = fKey;
    }

    public String getfKey() {
        return fKey;
    }
    
}

*** end *** end ***
***$$$@@@ /src/main/java/com/almatarm/mybatishelper/SingleField.java
package com.almatarm.mybatishelper;

/**
 *
 * @author <a href="mailto:almatarm@gmail.com">Mufeed H. AlMatar</a>
 * @version 1.0
 */
public class SingleField extends Field {
    
    String column;
    boolean findBy;
    boolean searchable;
    boolean selectAlone;
    boolean unique;

    public SingleField(String property, String column) {
        super(property);
        this.column = column;
        fieldType = FieldType.Single;
    }
    public String getColumn() {
        return column;
    }

    public void setColumn(String column) {
        this.column = column;
    }

    public boolean isFindBy() {
        return findBy;
    }

    public void setFindBy(boolean findBy) {
        this.findBy = findBy;
    }

    public boolean isSearchable() {
        return searchable;
    }

    public void setSearchable(boolean searchable) {
        this.searchable = searchable;
    }

    public boolean isSelectAlone() {
        return selectAlone;
    }

    public boolean isUnique() {
        return unique;
    }

    public void setUnique(boolean unique) {
        this.unique = unique;
    }

    public void setSelectAlone(boolean selectAlone) {
        this.selectAlone = selectAlone;
    }

    @Override
    public String toString() {
        return "SingleField{" + "column=" + column + ", findBy=" + findBy + ", searchable=" + searchable + ", selectAlone=" + selectAlone + ", unique=" + unique + '}';
    }

}

*** end *** end ***
